// Generated by CoffeeScript 1.10.0
(function() {
  var connectionStateMap, parsePatterns, powerStateMap;

  parsePatterns = {
    iwconfig_line: new RegExp(/([^ ]+)/),
    iw_dev_link_line: new RegExp(/([^:]+): ([^\n]+)/),
    iwlist: {
      new_cell: new RegExp(/.*BSS [0-9a-z]{2}:.*/),
      ssid: new RegExp(/.*SSID: (.*).*/),
      encryption: new RegExp(/.*Privacy.*/),
      signal: new RegExp(/.*signal: (-[0-9\.]+).*/),
      channel: new RegExp(/.*DS Parameter set: channel ([0-9]+)/)
    }
  };

  connectionStateMap = {
    connected: "connected",
    disconnected: "disconnected",
    connecting: "connecting"
  };

  powerStateMap = {
    enabled: true,
    disabled: false
  };

  module.exports = {
    autoFindInterface: function() {
      var _iface, _interface, _interfaceLine, _msg, findInterfaceCom, parsedLine;
      this.WiFiLog("Host machine is Linux.");
      findInterfaceCom = "iwconfig | grep 802.11";
      this.WiFiLog("Executing: " + findInterfaceCom);
      _interfaceLine = this.execSync(findInterfaceCom);
      parsedLine = parsePatterns.iwconfig_line.exec(_interfaceLine.trim());
      _interface = parsedLine[0];
      if (_interface) {
        _iface = _interface.trim();
        _msg = "Automatically located wireless interface " + _iface + ".";
        this.WiFiLog(_msg);
        return {
          success: true,
          msg: _msg,
          "interface": _iface
        };
      } else {
        _msg = "Error: No network interface found.";
        this.WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg,
          "interface": null
        };
      }
    },
    getIfaceState: function() {
      var KEY, VALUE, connectionState, connectionStateLines, error, error1, i, interfaceState, k, len, ln, parsedLine, ref;
      interfaceState = {};
      connectionState = this.execSync("iw dev " + this.WiFiControlSettings.iface + " link");
      if (connectionState.indexOf("command failed: no such device") === -1) {
        interfaceState.power = true;
        connectionStateLines = connectionState.split("\n");
        if (connectionStateLines[0].indexOf("Not connected") > -1) {
          interfaceState.connection = "disconnected";
        } else if (connectionStateLines[0].indexOf("Connected to") > -1) {
          interfaceState.connection = "connected";
          ref = connectionStateLines.slice(1);
          for (k = i = 0, len = ref.length; i < len; k = ++i) {
            ln = ref[k];
            try {
              parsedLine = parsePatterns.iw_dev_link_line.exec(ln.trim());
              KEY = parsedLine[1];
              VALUE = parsedLine[2];
            } catch (error1) {
              error = error1;
              continue;
            }
            switch (KEY) {
              case "SSID":
                interfaceState.ssid = VALUE;
                break;
            }
          }
          if (interfaceState.ssid == null) {
            interfaceState.ssid = null;
          }
        }
      } else {
        interfaceState.power = false;
        interfaceState.connection = "disconnected";
        interfaceState.ssid = null;
      }
      return interfaceState;
    },
    scanForWiFi: function() {
      var _network, channel_parse, i, k, len, line, ln, networks, ref, scanResults, signal_parse, ssid_parse;
      scanResults = this.execSync("sudo iw dev " + this.WiFiControlSettings.iface + " scan ap-force");
      networks = [];
      _network = {
        ssid: null,
        security: false,
        signal: null,
        channel: null
      };
      ref = scanResults.split("\n");
      for (k = i = 0, len = ref.length; i < len; k = ++i) {
        ln = ref[k];
        line = ln.trim();
        if (parsePatterns.iwlist.new_cell.test(ln)) {
          _network = {
            ssid: null,
            security: false,
            signal_level: null,
            channel: null
          };
          continue;
        }
        ssid_parse = parsePatterns.iwlist.ssid.exec(ln);
        if (ssid_parse) {
          _network.ssid = ssid_parse[1];
          if (_network.ssid.length) {
            networks.push(_network);
          }
          continue;
        }
        if (parsePatterns.iwlist.encryption.test(ln)) {
          _network.security = true;
        }
        channel_parse = parsePatterns.iwlist.channel.exec(ln);
        if (channel_parse) {
          console.log(channel_parse);
          _network.channel = parseInt(channel_parse[1]);
        }
        signal_parse = parsePatterns.iwlist.signal.exec(ln);
        if (signal_parse) {
          _network.signal = parseInt(signal_parse[1]);
        }
      }
      return networks;
    },
    connectToAP: function(_ap) {
      var COMMANDS, _msg, com, connectToAPChain, error, error1, error2, i, len, ssidExist, stdout;
      COMMANDS = {
        "delete": "nmcli connection delete \"" + _ap.ssid + "\"",
        connect: "nmcli device wifi connect \"" + _ap.ssid + "\""
      };
      if (_ap.password.length) {
        COMMANDS.connect += " password \"" + _ap.password + "\"";
      }
      try {
        stdout = this.execSync("nmcli connection show \"" + _ap.ssid + "\"");
        if (stdout.length) {
          ssidExist = true;
        }
      } catch (error1) {
        error = error1;
        ssidExist = false;
      }
      connectToAPChain = [];
      if (ssidExist) {
        this.WiFiLog("It appears there is already a connection for this SSID.");
        connectToAPChain.push("delete");
      }
      connectToAPChain.push("connect");
      for (i = 0, len = connectToAPChain.length; i < len; i++) {
        com = connectToAPChain[i];
        this.WiFiLog("Executing:\t" + COMMANDS[com]);
        try {
          stdout = this.execSync(COMMANDS[com]);
        } catch (error2) {
          error = error2;
          if (error.stderr.toString().trim() === ("Error: No network with SSID '" + _ap.ssid + "' found.")) {
            _msg = "Error: No network called " + _ap.ssid + " could be found.";
            this.WiFiLog(_msg, true);
            return {
              success: false,
              msg: _msg
            };
          } else if (error.stderr.toString().search(/Error:/ !== -1)) {
            _msg = error.stderr.toString().trim();
            this.WiFiLog(_msg, true);
            return {
              success: false,
              msg: _msg
            };
          }
          if (!/nmcli device wifi connect/.test(COMMANDS[com])) {
            this.WiFiLog(error, true);
            return {
              success: false,
              msg: error
            };
          }
        }
        this.WiFiLog("Success!");
      }
    },
    resetWiFi: function() {
      var COMMANDS, _msg, com, i, len, resetWiFiChain, results, stdout;
      COMMANDS = {
        disableNetworking: "sudo ifconfig " + this.WiFiControlSettings.iface + " down",
        enableNetworking: "sudo ifconfig " + this.WiFiControlSettings.iface + " up"
      };
      resetWiFiChain = ["disableNetworking", "enableNetworking"];
      results = [];
      for (i = 0, len = resetWiFiChain.length; i < len; i++) {
        com = resetWiFiChain[i];
        this.WiFiLog("Executing:\t" + COMMANDS[com]);
        stdout = this.execSync(COMMANDS[com]);
        _msg = "Success!";
        results.push(this.WiFiLog(_msg));
      }
      return results;
    }
  };

}).call(this);
